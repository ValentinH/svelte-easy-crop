{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../index.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import { createEventDispatcher, onDestroy, onMount } from 'svelte';\nimport * as helpers from './helpers';\nexport let image;\nexport let crop = { x: 0, y: 0 };\nexport let zoom = 1;\nexport let aspect = 4 / 3;\nexport let minZoom = 1;\nexport let maxZoom = 3;\nexport let cropSize = null;\nexport let cropShape = 'rect';\nexport let showGrid = true;\nexport let zoomSpeed = 1;\nexport let crossOrigin = null;\nexport let restrictPosition = true;\nlet cropperSize = null;\nlet imageSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 };\nlet containerEl = null;\nlet containerRect = null;\nlet imgEl = null;\nlet dragStartPosition = { x: 0, y: 0 };\nlet dragStartCrop = { x: 0, y: 0 };\nlet lastPinchDistance = 0;\nlet rafDragTimeout = null;\nlet rafZoomTimeout = null;\nconst dispatch = createEventDispatcher();\nonMount(() => {\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (imgEl && imgEl.complete) {\n        onImgLoad();\n    }\n    if (containerEl) {\n        containerEl.addEventListener('gesturestart', preventZoomSafari);\n        containerEl.addEventListener('gesturechange', preventZoomSafari);\n    }\n});\nonDestroy(() => {\n    if (containerEl) {\n        containerEl.removeEventListener('gesturestart', preventZoomSafari);\n        containerEl.removeEventListener('gesturechange', preventZoomSafari);\n    }\n    cleanEvents();\n});\n// this is to prevent Safari on iOS >= 10 to zoom the page\nconst preventZoomSafari = (e) => e.preventDefault();\nconst cleanEvents = () => {\n    if (typeof document !== 'undefined') {\n        document.removeEventListener('mousemove', onMouseMove);\n        document.removeEventListener('mouseup', onDragStopped);\n        document.removeEventListener('touchmove', onTouchMove);\n        document.removeEventListener('touchend', onDragStopped);\n    }\n};\nconst onImgLoad = () => {\n    computeSizes();\n    emitCropData();\n};\nconst getAspect = () => {\n    if (cropSize) {\n        return cropSize.width / cropSize.height;\n    }\n    return aspect;\n};\nconst computeSizes = () => {\n    if (imgEl) {\n        imageSize = {\n            width: imgEl.width,\n            height: imgEl.height,\n            naturalWidth: imgEl.naturalWidth,\n            naturalHeight: imgEl.naturalHeight,\n        };\n        cropperSize = cropSize ? cropSize : helpers.getCropSize(imgEl.width, imgEl.height, aspect);\n    }\n    if (containerEl) {\n        containerRect = containerEl.getBoundingClientRect();\n    }\n};\nconst getMousePoint = (e) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n});\nconst getTouchPoint = (touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n});\nconst onMouseDown = (e) => {\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onDragStopped);\n    onDragStart(getMousePoint(e));\n};\nconst onMouseMove = (e) => onDrag(getMousePoint(e));\nconst onTouchStart = (e) => {\n    document.addEventListener('touchmove', onTouchMove, { passive: false }); // iOS 11 now defaults to passive: true\n    document.addEventListener('touchend', onDragStopped);\n    if (e.touches.length === 2) {\n        onPinchStart(e);\n    }\n    else if (e.touches.length === 1) {\n        onDragStart(getTouchPoint(e.touches[0]));\n    }\n};\nconst onTouchMove = (e) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault();\n    if (e.touches.length === 2) {\n        onPinchMove(e);\n    }\n    else if (e.touches.length === 1) {\n        onDrag(getTouchPoint(e.touches[0]));\n    }\n};\nconst onDragStart = ({ x, y }) => {\n    dragStartPosition = { x, y };\n    dragStartCrop = { x: crop.x, y: crop.y };\n};\nconst onDrag = ({ x, y }) => {\n    if (rafDragTimeout)\n        window.cancelAnimationFrame(rafDragTimeout);\n    rafDragTimeout = window.requestAnimationFrame(() => {\n        if (x === undefined || y === undefined || !cropperSize)\n            return;\n        const offsetX = x - dragStartPosition.x;\n        const offsetY = y - dragStartPosition.y;\n        const requestedPosition = {\n            x: dragStartCrop.x + offsetX,\n            y: dragStartCrop.y + offsetY,\n        };\n        crop = restrictPosition\n            ? helpers.restrictPosition(requestedPosition, imageSize, cropperSize, zoom)\n            : requestedPosition;\n    });\n};\nconst onDragStopped = () => {\n    cleanEvents();\n    emitCropData();\n};\nconst onPinchStart = (e) => {\n    const pointA = getTouchPoint(e.touches[0]);\n    const pointB = getTouchPoint(e.touches[1]);\n    lastPinchDistance = helpers.getDistanceBetweenPoints(pointA, pointB);\n    onDragStart(helpers.getCenter(pointA, pointB));\n};\nconst onPinchMove = (e) => {\n    const pointA = getTouchPoint(e.touches[0]);\n    const pointB = getTouchPoint(e.touches[1]);\n    const center = helpers.getCenter(pointA, pointB);\n    onDrag(center);\n    if (rafZoomTimeout)\n        window.cancelAnimationFrame(rafZoomTimeout);\n    rafZoomTimeout = window.requestAnimationFrame(() => {\n        const distance = helpers.getDistanceBetweenPoints(pointA, pointB);\n        const newZoom = zoom * (distance / lastPinchDistance);\n        setNewZoom(newZoom, center);\n        lastPinchDistance = distance;\n    });\n};\nconst onWheel = (e) => {\n    const point = getMousePoint(e);\n    const newZoom = zoom - (e.deltaY * zoomSpeed) / 200;\n    setNewZoom(newZoom, point);\n};\nconst getPointOnContainer = ({ x, y }) => {\n    if (!containerRect) {\n        throw new Error('The Cropper is not mounted');\n    }\n    return {\n        x: containerRect.width / 2 - (x - containerRect.left),\n        y: containerRect.height / 2 - (y - containerRect.top),\n    };\n};\nconst getPointOnImage = ({ x, y }) => ({\n    x: (x + crop.x) / zoom,\n    y: (y + crop.y) / zoom,\n});\nconst setNewZoom = (newZoom, point) => {\n    if (!cropperSize)\n        return;\n    const zoomPoint = getPointOnContainer(point);\n    const zoomTarget = getPointOnImage(zoomPoint);\n    zoom = Math.min(maxZoom, Math.max(newZoom, minZoom));\n    const requestedPosition = {\n        x: zoomTarget.x * zoom - zoomPoint.x,\n        y: zoomTarget.y * zoom - zoomPoint.y,\n    };\n    crop = restrictPosition\n        ? helpers.restrictPosition(requestedPosition, imageSize, cropperSize, zoom)\n        : requestedPosition;\n};\nconst emitCropData = () => {\n    if (!cropperSize || cropperSize.width === 0)\n        return;\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ricardo-ch/svelte-easy-crop/issues/6)\n    const position = restrictPosition\n        ? helpers.restrictPosition(crop, imageSize, cropperSize, zoom)\n        : crop;\n    const { croppedAreaPercentages, croppedAreaPixels } = helpers.computeCroppedArea(position, imageSize, cropperSize, getAspect(), zoom, restrictPosition);\n    dispatch('cropcomplete', {\n        percent: croppedAreaPercentages,\n        pixels: croppedAreaPixels,\n    });\n};\n// ------ Reactive statement ------\n//when aspect changes, we reset the cropperSize\n$: if (imgEl) {\n    cropperSize = cropSize ? cropSize : helpers.getCropSize(imgEl.width, imgEl.height, aspect);\n}\n// when zoom changes, we recompute the cropped area\n$: zoom && emitCropData();\n</script>\n\n<svelte:window on:resize={computeSizes} />\n<div\n  class=\"container\"\n  bind:this={containerEl}\n  on:mousedown|preventDefault={onMouseDown}\n  on:touchstart|preventDefault={onTouchStart}\n  on:wheel|preventDefault={onWheel}\n  data-testid=\"container\"\n>\n  <img\n    bind:this={imgEl}\n    class=\"image\"\n    src={image}\n    on:load={onImgLoad}\n    alt=\"\"\n    style=\"transform: translate({crop.x}px, {crop.y}px) scale({zoom});\"\n    crossorigin={crossOrigin}\n  />\n  {#if cropperSize}\n    <div\n      class=\"cropperArea\"\n      class:round={cropShape === 'round'}\n      class:grid={showGrid}\n      style=\"width: {cropperSize.width}px; height: {cropperSize.height}px;\"\n      data-testid=\"cropper\"\n    />\n  {/if}\n</div>\n\n<style>\n  .container {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    overflow: hidden;\n    user-select: none;\n    touch-action: none;\n    cursor: move;\n  }\n\n  .image {\n    max-width: 100%;\n    max-height: 100%;\n    margin: auto;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    will-change: transform;\n  }\n\n  .cropperArea {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n    box-shadow: 0 0 0 9999em;\n    box-sizing: border-box;\n    color: rgba(0, 0, 0, 0.5);\n    border: 1px solid rgba(255, 255, 255, 0.5);\n    overflow: hidden;\n  }\n\n  .grid:before {\n    content: ' ';\n    box-sizing: border-box;\n    border: 1px solid rgba(255, 255, 255, 0.5);\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 33.33%;\n    right: 33.33%;\n    border-top: 0;\n    border-bottom: 0;\n  }\n\n  .grid:after {\n    content: ' ';\n    box-sizing: border-box;\n    border: 1px solid rgba(255, 255, 255, 0.5);\n    position: absolute;\n    top: 33.33%;\n    bottom: 33.33%;\n    left: 0;\n    right: 0;\n    border-left: 0;\n    border-right: 0;\n  }\n\n  .round {\n    border-radius: 50%;\n  }\n</style>\n"
  ],
  "names": [],
  "mappings": "AA+OE,UAAU,eAAC,CAAC,AACV,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,CAAC,CACT,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,IAAI,CACjB,YAAY,CAAE,IAAI,CAClB,MAAM,CAAE,IAAI,AACd,CAAC,AAED,MAAM,eAAC,CAAC,AACN,SAAS,CAAE,IAAI,CACf,UAAU,CAAE,IAAI,CAChB,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,MAAM,CAAE,CAAC,CACT,IAAI,CAAE,CAAC,CACP,KAAK,CAAE,CAAC,CACR,WAAW,CAAE,SAAS,AACxB,CAAC,AAED,YAAY,eAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,GAAG,CACT,GAAG,CAAE,GAAG,CACR,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,IAAI,CAAC,CAChC,UAAU,CAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CACxB,UAAU,CAAE,UAAU,CACtB,KAAK,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CACzB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAC1C,QAAQ,CAAE,MAAM,AAClB,CAAC,AAED,oBAAK,OAAO,AAAC,CAAC,AACZ,OAAO,CAAE,GAAG,CACZ,UAAU,CAAE,UAAU,CACtB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAC1C,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,MAAM,CAAE,CAAC,CACT,IAAI,CAAE,MAAM,CACZ,KAAK,CAAE,MAAM,CACb,UAAU,CAAE,CAAC,CACb,aAAa,CAAE,CAAC,AAClB,CAAC,AAED,oBAAK,MAAM,AAAC,CAAC,AACX,OAAO,CAAE,GAAG,CACZ,UAAU,CAAE,UAAU,CACtB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAC1C,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,MAAM,CACX,MAAM,CAAE,MAAM,CACd,IAAI,CAAE,CAAC,CACP,KAAK,CAAE,CAAC,CACR,WAAW,CAAE,CAAC,CACd,YAAY,CAAE,CAAC,AACjB,CAAC,AAED,MAAM,eAAC,CAAC,AACN,aAAa,CAAE,GAAG,AACpB,CAAC"
}